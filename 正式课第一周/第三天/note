1.且和或的用法：
&&:前面为真，才会走后面；
    cb && cb();
||:前面为假，才会走后面；
    var l=left||200;
2.if()条件判断的多种写法：
    1）普通写法
        if(a==2){
            alert(2)
        }
    2）&&
        a==2 && alert(2);
    3）if简写
        if(a==2) alert(2);
    4)三目：三元表达式
        a==2?alert(2):null;
.......................................
1.对象特征：属性,方法；
2.面向对象思想(oo思想，oop思想)；
3.面向对象的特点：
1）封装：对同一个功能的函数，只封装一次，以后再遇到此功能，只需要调用即可，无需重写；避免大量冗余代码；低耦合高内聚；
2）继承：子类可以继承父类的属性和方法；
3）多态：多种形态； 重载 和 重写；
重载：JS没有严格意义上的重载，有类似重载的功能，传不同的参数，可以实现不同的功能；
重写：子类可以重写父类的属性和方法；
4.单例模式：把描述同一个对象的属性和方法，都放在同一个命名空间下；避免全局变量的污染和冲突；
命名空间:把描述这个对象的属性和方法，所存放的空间，起个名字，比如person1：就是命名空间
单利模式的本质：普通对象；
5.模块化开发：--单例模式就是最简单的模块化开发；
对于一个大型项目，会分配给不同的工程师，进行同步开发；等所有的人都开发完成，最后进行代码合并；
6.单例模式的优缺点：
1）优点：
    1.单例模式可以避免全局变量的污染和冲突
    2.单例模式是最简单的模块化开发：
        1）本模块之间的相互调用：this.属性名
        2）不同模块之间的相互调用：模块名.属性名
2）缺点：当多个对象功能一样，会存在大量冗余代码
解决措施：工厂模式；
7.工厂模式的本质-封装；
1）引进原材料            创建一个空对象 {}   new Object();
2）加工                 给对象添加属性和方法
3）输出产品              输出已经加工后的对象；
8.如果想让工厂模式的调用方式，跟系统类的调用方式一样；需要做两步：
1）首字母大写
2）添加New;
9.构造函数模式 跟 工厂模式的区别
1）调用的时候：
工厂模式：普通函数的调用 //person();
构造函数：new+首字母大写() //new Person();
2)函数体内的不同：
工厂模式：三步 1）创建对象 2）加工对象 3）返回对象
构造函数模式：一步 加工对象；
10）this总结：
1）元素身上的事件被触发的时候，会执行一个函数，函数中的this，指向当前这个元素
2）自执行函数中的this，永远都是window；
3）函数被调用的时候，看前面是否有点，点前是谁，this就是谁
4）构造函数的中的this，是实例；
11）学习构造函数的目的：
1）了解系统类的构成；
2）自己定义一个类，并且创建实例；
12）关于构造函数的小细节：
1）构造函数中的this都是实例；
2）构造函数中存放的都是私有的属性和方法；
3) 实例只跟构造函数中的this.xxx有关，跟var没有任何关系；
4）构造函数中，系统默认为我们创建一个实例，并且默认返回一个实例；
   不建议自己手动返回对象，如果非要手动返回的话：
    1）返回的是基本数据类型,无效，实例该有的属性和方法仍然有；
    2）返回的是引用数据类型，以前给实例上添加的属性和方法都无效了；
5）构造函数： 实例 和 类 打交道
6）在new一个实例的时候，如果不需要传参，()可以省略；
13)原型模式的基础知识：
    1.每个函数数据类型(普通函数，构造函数)上，都有一个属性，叫做prototype，prototype是个原型；
    2.prototype这个对象上，存放的都是共有的属性和方法，他天生自带一个属性constructor,指向当前这个构造函数；
    3.每个对象数据类型（实例，prototype,普通对象）上，都有一个属性叫做__proto__,指向当前实例所属类的原型；
14)Object.prototype上的方法：
hasOwnProperty():判断是否为对象的私有属性
obj1.isPrototypeOf(obj2) :obj1是否在obj2的原型链上；
propertyIsEnumerable：是否为可枚举的属性
15）__proto__原型链：
如果想查找：对象.属性名
1）先看该对象的私有空间中是否有，如果有，说明这个属性是私有属性；
2）如果没有，通过__proto__继续往当前实例所属类的原型上找，找到了，说明是公有属性；
3）找不到继续通过__proto__一直往上找，找到基类Object.prototype原型上，还没有的话undefined;












